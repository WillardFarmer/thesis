\glsresetall{} 
\chapter{Introduction}\label{chap:intro}
%\subsection{Small Satellites and New Space}


\section{Thesis Overview}


\lettrine[lines=2, findent=0pt, nindent=5pt]{O}{} ver the past decade, there
has been a sharp rise in the development of small spacecraft. With 112
nanosatellites launched in 2012 and 1800 launched in 20221, it is clear that
the industry is growing. As technology improves, so too do the capabilities of
small spacecraft. For missions with relatively ‘simple’ operations, it is
economical to use competent engineers to handle orbit operations. But, as
missions become more complex, more of the operator’s time is spent on repeated
calculations using purpose-built scripts that offer little in terms of
reusability. For suitably complicated operations, the economy of human
computation is lost. In this scenario, the benefits of software automation
become appealing. Commercial-off-the-shelf tools do exist to address this
issue. A ready example would be Orbit Logic’s \gls{cpaw}2 or their Scheduler
extension for the Ansys \gls{stk}3. These solutions are well-developed and have
a proven mission heritage. They are also quite expensive and still require
adapting to a specific mission scenario.  \\ 


At the \gls{sfl}, the \gls{pops} is being developed to streamline operations
planning for remote sensing missions. \gls{pops} is a general offline software
meant to handle the deterministic aspects of mission planning.  Given an
\gls{aoi} and a method of remote sensing, \gls{pops} presents possible
observation opportunities to the operator and creates sets of commands to be
uploaded to a spacecraft in orbit.  Ideally, \gls{pops} should prevent an
operator from having to do any calculations themselves manually. Not only is
\gls{pops} meant to be a tool used by \gls{sfl} operators but one of the goals
of this project is to reduce the barrier to development as much as possible.
The easier the underlying code is to work with, the more likely it is that
future developers work on it and the tool grows. For this reason, most of the
underlying code for \gls{pops} has been written in Python and leverages several
open-source libraries.  Extending this principle, \gls{pops} uses a
browser-based \gls{gui} rather than as an executable desktop application. As a
browser-based application, \gls{pops} can leverage an extensive set of existing
libraries for building functionality.  For example, CesiumJS4 may be used for
graphical Earth visualizations.  \gls{pops}’s architecture is containerized for
easy deployment, using Docker5.  Each service handles separate aspects of the
software’s functionality.  In this way, they can be developed separately and
switched out as needed. With services, functionality may also be integrated
into other applications. For persistent storage of planning information, an SQL
database has been implemented as its own service.  To facilitate searching for
observation opportunities, a suite of software tools has been developed, known
as the \gls{atu}.  \gls{pops} also handles its orbital propagation by making use of
open-source Python implementations of the SGP4 algorithm. 


\section{Existing Solutions}\label{sec:exsoln}

Mission planning is not unique to \gls{sfl}. Leveraging software automation
should be done for any mission with sufficiently complicated operations.  As
such, existing mission planning solutions already exist. For these existing
solutions though, we should keep in mind the microspace design approach. Even
though there may exist software that finds the best possible solutions with the
best algorithms and interface, can the same results be achieved through a more
limited but still satisfactory solution? 


\subsection{Collection Planning and Analysis Workstation}

The \acrfull{cpaw} is the one of the more sophisticated operations planning
tools available on the market.  Developed by Orbit Logic, \gls{cpaw} has a
mission heritage and has been used for planning imaging operations for: Landsat
8/9~\cite{gokhale_mission_nodate}, Worldview-1/2, GeoEye-1, and
RADARSAT-2~\cite{herz_eo_2014}. Typically, \gls{cpaw}'s use case is for medium
to large constellations of synthetic-aperture RADAR or electro-optical
satellites. It combines dynamic modeling of the spacecraft with optimized
schedule planning. These schedules can then be used to generate commands to be
sent to the spacecraft. Planning may either be done manually or automatically. 

This is a very appealing solution but it has some limitations. Firstly,
\gls{cpaw} is expensive and licensing the software would require yearly
payments per mission. License fees does not necessarily preclude the use of
\gls{cpaw}, rather it is the fact that not all of \gls{cpaw}'s capabilities are
necessary.  \gls{sfl} does not require a tool that fully automates satellite
operations, rather it needs a tool that automates repetitive calculations.
Operators will still be in the loop setting plans for satellites. \gls{cpaw}
also provides a suite of proprietary algorithms that produce an optimized
operations schedle.  While this would be a nice to have, an optimal schedule is
equivalent to a satisfactory schedule if both meet their operational
requirements. Time and money spent towards approaching optimality could be
wasted. In addition, out-of-the-box, \gls{cpaw} does not provide support for
all of the operations modes performed at \gls{sfl}. These modes would need to
be developed and integrated into the software. This limits \gls{cpaw} to only
the mission that it is licensed for and cannot be extended to future missions
without new licensing.


\subsection{STK Scheduler} 

STK Scheduler is an extension to the Ansys \acrlong{stk} developed by orbit
logic. It provides the scheduling utility of \gls{cpaw} but utilizes objects
defined in \gls{stk}. That is, the scheduling algorithms build off of the
flight dynamics from \gls{stk} to generate optimal schedules. Operators at
\gls{sfl} are already very experienced with \gls{stk} so utilitizing a plugin
that supports schedule creation is appealing.

Similar to \gls{cpaw}, \gls{stk} Scheduler also requires a license fee payed
yearly. If mission planning only needs to be done for a single mission, this
would be a good cost-effective solution. But, for multiple missions, they must
either use the same license, which may become challenging logistically, or
multiple licenses would need to be procured.


\subsection{Mission Planning and Scheduling Software}

The \gls{mpss} was developed for the NEMO-AM by \gls{sfl} in 2013~\cite{payam}.
Its purpose was to facilitate operations planning for Earth observation
missions at \gls{sfl}. It was designed with the NEMO-AM mission in mind and
incorperated: orbit visualization, attitude control algorithms, star tracker
data, \gls{gps} data, orbit propagation, and spacecraft command generation.
Having an already built in-house solution would be an ideal foundation to build
a new tool off of. 

There are a number of drawbacks to using the \gls{mpss}, though. The first
issue is that the software was developed in 2013 and built to run on the
\textit{RedHat Enterprise Linux 5}. The operating system was a specific
requirement from the customer and is not used or supported by \gls{sfl}. At the
very least using the tool would require updating all of the libraries to newer
versions. Some libraries may not even be supported 9 years later. Building off
of the \gls{mpss} locks development to decisions made that were reasonable in
2013, by may note be valid for our current puproses. For example, should the
new software be a desktop application using Qt for its \gls{gui}? Or, should
the new software directly handle attitude control sensor data. These are very
mission specific and potentially limit the software extensibility. Lastly, the
\gls{mpss} was designed with operation mode in mind. The new software solution
should be able to be extensible to different operations modes.    


\section{Thesis Outline} 

The puprpose of this Thesis is to summarize the development of the
\acrlong{pops}. As well, its purpose is to highlight some of the challenges
that go along with creating a mission plannng software. In
Chapter~\ref{chap:ops}, some operations concepts are discussed such as
terminology and the use of \glspl{ttc}. An example scenario is also introduced
to demonstrate how \gls{pops} may be used without giving away \gls{sfl}'s
customers' operations strategies. In Chapter~\ref{chap:architecture}, the
software architecture of \gls{pops} is discussed. This is the largest chapter
as it goes into the different services provided by \gls{pops}. In Chapter
\ref{chap:workflow}, we walk through how \gls{pops} may be used for the example
scenario introduced in Chapter~\ref{chap:ops}. Finally, the thesis is concluded
in Chapter~\ref{chap:conclusion}. After the conclusion, some algorithms of note
are discussed in the appendix.




